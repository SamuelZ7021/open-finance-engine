package com.backend.infrastructure.adapter.out.persistence;

import com.backend.application.port.out.TransactionPort;
import com.backend.domain.model.LedgerTransaction;
import com.backend.domain.model.TransactionLine;
import com.backend.infrastructure.adapter.out.persistence.entity.TransactionEntity;
import com.backend.infrastructure.adapter.out.persistence.entity.TransactionLineEntity;
import com.backend.infrastructure.adapter.out.persistence.repository.SpringDataTransactionRepository;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Component
public class TransactionPersistenceAdapter implements TransactionPort {

    private final SpringDataTransactionRepository transactionRepository;

    public TransactionPersistenceAdapter(SpringDataTransactionRepository transactionRepository) {
        this.transactionRepository = transactionRepository;
    }

    @Override
    public void save(LedgerTransaction transaction) {
        TransactionEntity entity = toEntity(transaction);
        transactionRepository.save(entity);
    }

    @Override
    public boolean existsByIdempotencyKey(String key) {
        return transactionRepository.existsByIdempotencyKey(key);
    }

    @Override
    public Optional<LedgerTransaction> findById(UUID id) {
        return transactionRepository.findById(id).map(this::toDomain);
    }

    public List<LedgerTransaction> findByAccountId(UUID accountId) {
        return transactionRepository.findAllByAccountId(accountId)
                .stream()
                .map(this::toDomain)
                .toList();
    }
    private TransactionEntity toEntity(LedgerTransaction domain) {
        TransactionEntity entity = new TransactionEntity();

        entity.setId(domain.getId());
        entity.setTimestamp(domain.getTimestamp());
        entity.setDescription(domain.getDescription());
        entity.setIdempotencyKey(domain.getIdempotencyKey());

        // CRITICAL SECTION: Mapping the Lines
        // We must map the domain lines to entity lines AND set the parent reference.
        List<TransactionLineEntity> lineEntities = domain.getLines().stream()
                .map(line -> toLineEntity(line, entity)) // Pass the parent 'entity'
                .collect(Collectors.toList());

        entity.setLines(lineEntities);

        return entity;
    }

    private TransactionLineEntity toLineEntity(TransactionLine domainLine, TransactionEntity parent) {
        TransactionLineEntity lineEntity = new TransactionLineEntity();

        // Note: The ID is generated by JPA (@GeneratedValue), so we don't set it here unless the domain has it.
        // Since TransactionLine is a Value Object in domain, it might not have a global ID.

        lineEntity.setAccountId(domainLine.accountId());
        lineEntity.setAmount(domainLine.amount());
        lineEntity.setType(domainLine.type());

        // THE FIX: Establish the relationship back to the parent.
        // Without this line, the foreign key 'transaction_id' in the DB will be NULL.
        lineEntity.setTransaction(parent);

        return lineEntity;
    }

    private LedgerTransaction toDomain(TransactionEntity entity) {
        // Usamos el constructor de tu modelo de dominio LedgerTransaction
        LedgerTransaction domain = new LedgerTransaction(
                entity.getId(),
                entity.getDescription(),
                entity.getIdempotencyKey(),
                null, // parentTransactionId (puedes aÃ±adirlo si lo implementamos)
                null  // metadata
        );

        entity.getLines().forEach(line ->
                domain.addLine(line.getAccountId(), line.getAmount(), line.getType())
        );

        return domain;
    }
}
